## This implementation uses Merge Sort to efficiently solve LeetCode 912.

class Solution:
    def merg(self,nums,l,mid,r):
        a = []
        b = []
        for i in range(l,mid+1):
            a.append(nums[i])
        for i in range(mid+1,r+1):
            b.append(nums[i])

        i,j,k = 0,0,l
        while k<=r:
            if i == len(a):
                nums[k] = b[j]
                j+=1
                k+=1
            elif j == len(b):
                nums[k] = a[i]
                i+=1
                k+=1
            elif a[i]<b[j]:
                nums[k] = a[i]
                i+=1
                k+=1
            else:
                nums[k] = b[j]
                j+=1
                k+=1

    def mergsort(self,nums,l,r):
        if l>=r:
            return

        #RECURSION
        mid = (l+r)//2
        self.mergsort(nums,l,mid)
        self.mergsort(nums,mid+1,r)

        self.merg(nums,l,mid,r)
    def sortArray(self, nums: List[int]) -> List[int]:
        self.mergsort(nums,0,len(nums)-1)
        return nums

# This implementation is based on Bubble Sort.
# Although it produces correct results, it exceeds the time limit (TLE) on LeetCode 912 

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

        n = len(nums)
        
        for i in range(n):
            for j in range(n-i-1):
                if nums[j] > nums[j+1]:
                    #swaping
                    temp = nums[j]
                    nums[j] = nums[j+1]
                    nums[j+1] = temp
        return nums


# This implementation is based on Insertion Sort.
# Although it produces correct results, it exceeds the time limit (TLE) on LeetCode 912 

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        n = len(nums)

        for i in range(1,n):
            key = nums[i]
            j = i-1
            while j>=0 and nums[j]>key:
                nums[j+1] = nums[j]
                j-=1
            nums[j+1] = key
        return nums

# This implementation is based on Selection Sort.
# Although it produces correct results, it exceeds the time limit (TLE) on LeetCode 912 

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        n = len(nums)

        for i in range(n):
            mn = nums[i]
            idx = i
            for j in range(i+1,n):
                if nums[j]<mn:
                    mn = nums[j]
                    idx = j
            temp = nums[i]
            nums[i] = nums[idx]
            nums[idx] = temp
        return nums

# This implementation is based on Quick Sort.
# Although it produces correct results, it exceeds the time limit (TLE) on LeetCode 912 

class Solution:
    def partion(self,nums,l,r):
        key = nums[r]
        start = l

        for i in range(l,r+1):
            if nums[i]<=key:
                temp = nums[i]
                nums[i] = nums[start]
                nums[start] = temp
                start+=1
        return start-1  # return -1 because it goes 1 index forword to partion
    def quicksort(self,nums,l,r):
        #base case
        if l>=r:
            return
        p = self.partion(nums,l,r)
        self.quicksort(nums,l,p-1)
        self.quicksort(nums,p+1,r)
    def sortArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        self.quicksort(nums,0,n-1)
        return nums
